#  Apache-DBUtils实现CRUD操作

code:https://github.com/ytwotap/java-basics/tree/master

maven 库:https://mvnrepository.com/artifact/commons-dbutils/commons-dbutils/1.7

## 1 Apache-DBUtils简介

- commons-dbutils 是 Apache 组织提供的一个**开源 JDBC工具类库**，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。

  > DBUtils功能比较简单,所以**不能算框架.**

  > 框架:就是一个半成品的软件,有一个公共的功能.但是不能作为一个产品独立运行.
  >
  > 我们其实用框架其实就是在框架的基础上进行二次开发,开发出适合适合我们业务需求的产品. 框架就好比毛坯房.不能住人.我们产品就是装修房,可以住人.
  >
  > 由于每个人的装修不一样,所以功能也是不一样的,但是基础属性是差不多的.
  >
  > **框架+自己写的代码=能运行的软件.**

- API介绍：

  - org.apache.commons.dbutils.QueryRunner
  - org.apache.commons.dbutils.ResultSetHandler
  - 工具类：org.apache.commons.dbutils.DbUtils   

- API包说明：

![1555595163263](https://raw.githubusercontent.com/ytwotap/imgCloud/main/typora/jdbc/1555595163263.jpg)

![1555595198644](https://raw.githubusercontent.com/ytwotap/imgCloud/main/typora/jdbc/1555595198644.jpg)





## 2  使用

### 2.0 概况

#### **作用:**

主要是帮助我们跟见到的去执行SQL语句,更方便的去解析结果集

#### 如何使用

1. 下载在maven到pom

   ```
   <!-- https://mvnrepository.com/artifact/commons-dbutils/commons-dbutils -->
   <dependency>
       <groupId>commons-dbutils</groupId>
       <artifactId>commons-dbutils</artifactId>
       <version>1.7</version>
   </dependency>
   ```

2. 配置环境和连接mysql

   下面是配置 mysql连接和 Druid

   ```
   <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
   <dependency>
       <groupId>mysql</groupId>
       <artifactId>mysql-connector-java</artifactId>
       <version>8.0.25</version>
   </dependency>
   <!--druid-->
   <!-- https://mvnrepository.com/artifact/com.alibaba/druid -->
   <dependency>
       <groupId>com.alibaba</groupId>
       <artifactId>druid</artifactId>
       <version>1.2.6</version>
   </dependency>
   ```

3. 使用

### 2.1 DbUtils(没啥用 )

- DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：
  - **public static void close(…) throws java.sql.SQLException**：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。
  - public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。
  - public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接
  - public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 
  - public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断
  - public static void rollbackAndClose(Connection conn)throws SQLException
  - rollbackAndCloseQuietly(Connection)
  - public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。

### 2.2 QueryRunner类(有用的)

**`该类简单化了SQL查询`，**它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。

- ### QueryRunner类提供了两个构造器：
  
  - 默认的构造器
  - 需要一个 javax.sql.DataSource 来作参数的构造器
  
- ### QueryRunner类的主要方法：
  
  - ### **更新**
    
    - public int update(Connection conn, String sql, Object... params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。
    - ......
  - ### **插入**
    
    - public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object... params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值
    - ....
  - ### **批处理**
    
    - public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句
    - public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：只支持INSERT语句
    - .....
  - ### **查询**
    
    - public Object query(Connection conn, String sql, ResultSetHandler rsh,Object... params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。
    - ...... 
  
- 测试

```java
// 测试添加
@Test
public void testInsert() throws Exception {
	QueryRunner runner = new QueryRunner();
	Connection conn = JDBCUtils.getConnection3();
	String sql = "insert into customers(name,email,birth)values(?,?,?)";
	int count = runner.update(conn, sql, "何成飞", "he@qq.com", "1992-09-08");

	System.out.println("添加了" + count + "条记录");
		
	JDBCUtils.closeResource(conn, null);

}
```

```java
// 测试删除
@Test
public void testDelete() throws Exception {
	QueryRunner runner = new QueryRunner();
	Connection conn = JDBCUtils.getConnection3();
	String sql = "delete from customers where id < ?";
	int count = runner.update(conn, sql,3);

	System.out.println("删除了" + count + "条记录");
		
	JDBCUtils.closeResource(conn, null);

}
```

```java
/**
update 
*/
public class DBUtilDemo {
    public static void main(String[] args) throws SQLException {
        /*获取连接*/
        Connection con= DruidUtils.getConnection();
        String sql=" update  user set username='pigpig' where id=2";
        /*create a QueryRunner objec
        can tranfer obejct for datasource or null;
        t*/
        final QueryRunner queryRunner = new QueryRunner();
        final int update = queryRunner.update(con, sql);
        System.out.println("rows is updated:"+update);

//close source
        con.close();
    }
}
```

QueryRunner api选择:

QueryRunner api的选择需要根据是否传入数据库连接池开确定.

1. 传入无参构造方法,在执行sql的时候,一定要选带connection 对象.
2. 有参构造带DataSource 的 , 就不需要选带connnection 的.

### 2.3 ResultSetHandler接口及实现类(使用了反射注入bean对象,反射的实际使用)

原理:如何处理结果集的

`使用反射注入,实现bean对象赋值`

> **note:使用反射,可以将未知结构预留位置,进行拆解结构使用.从而实现灵活的bean注入. 来实现高耦合低内聚.**
>
> 相当于是一个细节位置,固定的结构.可以

- 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。

- ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。

- 接口的主要实现类：

  - ArrayHandler：把结果集中的第一行数据转成对象数组。

  - ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。

  - **BeanHandler：**将结果集中的第一行数据封装到一个对应的JavaBean实例中。

  - **BeanListHandler：**将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。

  - **ColumnListHandler**：将结果集中某一列的数据存放到List中。

  - KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。

  - **MapHandler：**将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。

  - **MapListHandler：**将结果集中的每一行数据都封装到一个Map里，然后再存放到List

  - **ScalarHandler：**查询单个值对象,将单个值封装，可以用来统计聚合函数count(),max(),min(),avg()等方法返回的值

    
    
  
  测试


```java
/*
 * 测试查询:查询一条记录
 * 
 * 使用ResultSetHandler的实现类：BeanHandler
 */
@Test
public void testQueryInstance() throws Exception{
	QueryRunner runner = new QueryRunner();

	Connection conn = JDBCUtils.getConnection3();
		
	String sql = "select id,name,email,birth from customers where id = ?";
		
	//
	BeanHandler<Customer> handler = new BeanHandler<>(Customer.class);
	Customer customer = runner.query(conn, sql, handler, 23);
	System.out.println(customer);	
	JDBCUtils.closeResource(conn, null);
}
```

```java
/*
 * 测试查询:查询多条记录构成的集合
 * 
 * 使用ResultSetHandler的实现类：BeanListHandler
 */
@Test
public void testQueryList() throws Exception{
	QueryRunner runner = new QueryRunner();

	Connection conn = JDBCUtils.getConnection3();
		
	String sql = "select id,name,email,birth from customers where id < ?";
		
	//
	BeanListHandler<Customer> handler = new BeanListHandler<>(Customer.class);
	List<Customer> list = runner.query(conn, sql, handler, 23);
	list.forEach(System.out::println);
		
	JDBCUtils.closeResource(conn, null);
}
```

```java
/*
 * 自定义ResultSetHandler的实现类
 */
@Test
public void testQueryInstance1() throws Exception{
	QueryRunner runner = new QueryRunner();

	Connection conn = JDBCUtils.getConnection3();
		
	String sql = "select id,name,email,birth from customers where id = ?";
		
	ResultSetHandler<Customer> handler = new ResultSetHandler<Customer>() {

		@Override
		public Customer handle(ResultSet rs) throws SQLException {
			System.out.println("handle");
//			return new Customer(1,"Tom","tom@126.com",new Date(123323432L));
				
			if(rs.next()){
				int id = rs.getInt("id");
				String name = rs.getString("name");
				String email = rs.getString("email");
				Date birth = rs.getDate("birth");
					
				return new Customer(id, name, email, birth);
			}
			return null;
				
		}
	};
		
	Customer customer = runner.query(conn, sql, handler, 23);
		
	System.out.println(customer);
		
	JDBCUtils.closeResource(conn, null);
}
```

```java
/*
 * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据，
 * 使用ScalarHandler
 * 
 */
@Test
public void testQueryValue() throws Exception{
	QueryRunner runner = new QueryRunner();

	Connection conn = JDBCUtils.getConnection3();
		
	//测试一：
//	String sql = "select count(*) from customers where id < ?";
//	ScalarHandler handler = new ScalarHandler();
//	long count = (long) runner.query(conn, sql, handler, 20);
//	System.out.println(count);
		
	//测试二：
	String sql = "select max(birth) from customers";
	ScalarHandler handler = new ScalarHandler();
	Date birth = (Date) runner.query(conn, sql, handler);
	System.out.println(birth);
		
	JDBCUtils.closeResource(conn, null);
}

```

ScalarHandler:

将单个值封装，可以用来统计聚合函数count(),max(),min(),avg()等方法返回的值

```java
// 获取单个值
public class ScalarHandlerDemo {

    public static void main(String[] args) throws SQLException {


        // 创建QUeryRUnner
        QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource());

        Long count = queryRunner.query("select count(id) from user", new ScalarHandler<>());

        System.out.println("count:" + count);
    }
}
```

