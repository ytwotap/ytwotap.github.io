# 接口

> 引例
>
> 回想Animal继承体系的案例，现在我们把Animal设计成抽象类
>
> 产品经理给了新需求

- 现在有一部分猫和狗，经过了特殊训练
  - 都可以直立行走（Wlak Upright）和骑自行车（Ride Bike）

- 那么该怎么去描述这群特殊的猫狗呢？





​	

















> 显然，如果直接将这些特殊的行为加入到猫、狗的类定义中是不合适的
>
> 因为，不是所有的猫、狗都会这些特殊技能
>
> 可以考虑重新定义特殊的猫狗类（SpecialCat）然后将这些特殊的行为加入到新定义的类中
>
> 这么做不是不行，但是没有对代码进行复用，如果又有一批特殊训练的猴子、狮子等动物呢？
>
> 可能你会想到定义一个装着特殊行为的类，然后让SpecialCat继承它
>
> 但是很可惜Java不支持多继承，我们以往的知识已经不能处理这种情况了

> 总结：

- 一方面，我们有时需要从多个类中派生出一个类，继承它们所有的成员，Java语法不适用
  - Java不支持多继承
- 另一方面，我们有时候需要从几个类中抽取出共同的行为特征
  - 而它们之间并没有“is-a”关系，继承思想显得不适用

> 于是：

- 为了复用这些“特殊行为”，我们迫切需要一种新的数据格式
  - 和类相似，可以抽取出共性，定义成员
  - 不受Java单继承限制
- 这种新的数据格式就是接口



> 接口的定义

- 语法

  ```java 
  [访问权限修饰符] interface 接口名{}
  ```

- 接口不是类，而是一种独立的数据类型，和class并列

  - 一个类实现的接口，也称之为接口的子类

- 一个类继承接口，称之为实现接口，使用关键字implements

  - 语法

    ```Java
    class 类名 implements 接口名 {}
    ```

  - 当一个类继承另一个类的同时，又实现接口

    - 必须要将实现接口放在继承类后面



 



> 接口概述

- interface表示一种数据类型，和class同级别
  - 是一种引用数据类型
  - 区别是：
    -  类定义的是一个数据集合基于这个数据集的一组操作(行为)
      - 类所描述的这一组行为，它们是有关系的（间接），都可以访问同一个数据集合
    - 接口表示数据类型，侧重于描述一组具有特殊功能的行为，这些行为
      - 可以完全没有任何关系。接口中的方法，它们的关系比较的松散
  - 类实现接口本质上也是一种继承，接口的实现类是接口的子类
  - 接口不能实例化
  - 接口不受多继承限制，接口可以多实现



> 接口的声明特征

- 接口的声明中默认存在一个abstract，所以接口必然是抽象的
- 接口普遍声明为public 鼓励继承（实现）





> 接口的成员特征：
>
> - 成员变量
> - 成员方法
> - 构造方法

- 接口中的所有成员变量都默认是由public static final修饰的

  - 无法使用除public外的访问权限修饰符，修饰成员变量
  - 普遍来说，开发时在接口中定义成员变量省略public static final
  - 但是接口内部不支持用static代码块给成员变量初始化
    - 必须要提供显式的初始化

- 接口中的所有方法都默认是由public abstract修饰的

- （了解即可）在JDK8中引入了默认方法

  - 语法

    ```java 
    default 返回值类型 方法名{
    }
    ```

  - 默认是public修饰

  - 不能用static、abstract修饰

  - 和抽象类中的具体方法一样，接口中的方法是给子类提供了一个默认实现

    - 子类可以选择直接继承使用该方法，也可以重写
    - 可以用子类对象调用，包括多态形式

  - 抽象类中有普通方法是很正常的，但是接口中不应该有具体方法，除非

    - 为了代码的兼容考虑
    - 例如class A、B、C很多类都实现了接口ITest，现在给接口新增了一个方法
      - 但这个方法不是所有类都需要重写的
      - 如果这个方法是一个抽象方法，所有类都必须实现该方法，否则会报错
      - 为了省事，可以选择default方法
      - 实际上Java8之所以引入default方法就是为了做这种事情
      - 省事是Java开发者省事，你不要省事

- （了解即可）在JDK8中引入了静态方法

  - 语法

    ```Java
    static 返回值类型 方法名{
    }
    ```

  - 默认是public修饰

  - 不能用abstract、default修饰

  - 可以使用接口名点方法名访问

- 从技术角度来说，以上实现方法是完全合法的

  - 只是它看起来违反了接口作为一个抽象定义的理念
  - 除非特别有必要，不要使用

- 接口没有构造方法，接口中的成员变量都是常量，不需要子类调用构造方法来初始化



> 接口的子类特征：

- 如果是一个类实现了接口
  - 必须要重写接口中所有的抽象方法，除非该类是一个抽象类
  - 一个类实现了接口，就变成了接口的子类
  - 接口可以多实现，配合default方法可以实现真正意义上的多继承（最好不要这么干）
  - 如果一个类又继承类又实现接口，一定是先继承再实现，顺序不能互换
- 如果是一个抽象类实现了接口
  - 可以不重写接口中的抽象方法
  - 可以实现多个接口而不重写方法
  - 抽象类也可以继承普通类
- 如果一个接口继承了接口
  - 接口之间不能互相实现，但是可以继承
  - 接口可以多继承，一个接口可以extends多个接口
  - 接口不可以继承类class

```
现在做一个接口和类之间的继承与实现的关系总结:
  1,同种族之间只能extends
      类之间单继承
      接口之间多继承
  1,类可以实现接口用implements
  3,接口不能对类做继承或者实现操作
```



> 接口使用注意事项：

- 定义Java类的语法格式：先写extends，后写implements

  - ```Java
    class SubClass extends SuperClass implements InterfaceA{
    } 
    ```

- 一个类可以实现多个接口，接口也可以继承其它接口，这就是Java当中的“多继承”

- 实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类

- 接口的主要用途就是被实现类实现

  - 所以接口和接口的成员默认都是public修饰，鼓励继承，鼓励重写

- 与继承关系类似，接口与实现类之间存在多态性

- 接口和类是并列的数据类型





> 接口和抽象类的异同

| 编号 | **区别点** |                          **抽象类**                          |                 **接口**                  |
| :--: | :--------: | :----------------------------------------------------------: | :---------------------------------------: |
|  1   |    定义    |                       包含抽象方法的类                       |         抽象方法和全局常量的集合          |
|  2   |    组成    |           构造方法、抽象方法、普通方法、常量、变量           | 常量、抽象方法、(jdk8:默认方法、静态方法) |
|  3   |    使用    |                   子类继承抽象类(extends)                    |         子类实现接口(implements)          |
|  4   |    关系    |                    抽象类可以实现多个接口                    |  接口不能继承抽象类，但允许继承多个接口   |
|  5   |    对象    |                 不能创建对象，但是有构造方法                 |       不能创建对象，也没有构造方法        |
|  6   |    局限    |                      抽象类不能被多继承                      |       接口之间能多继承，能被多实现        |
|  7   |    思想    |                  作为模板或对共性抽象，is-a                  |     作为标准或对共性能力抽象，like-a      |
|  8   |    选择    | 如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限 |                                           |



Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：

- 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
- 类可以实现很多个接口，但是只能继承一个抽象类
- 类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
- 抽象类可以在不提供接口方法实现的情况下实现接口。
- Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
- Java接口中的成员方法默认是public的。抽象类的成员方法可以是private，protected或者是public。





>  接口就是这样的一种规范，它抽取了事物的相似行为，而不关心事物有什么关系

- 相比于继承抽象类的“is-a”关系，体现的是“是XX”思想，而实现接口体现的是“能够XX”的思想

- 接口允许多实现。实现多个接口，继承它们所有的属性和方法

- **接口的本质是契约、规范、标准**











> 小试牛刀
>
> 请用所学知识分析：
>
> 这个案例中有哪些抽象类，哪些接口，哪些具体类。

- 教练（Coach）和运动员（Sportsman）案例

  - 乒乓球（TableTennis）运动员和篮球（basketball）运动员

  - 乒乓球教练和篮球教练

  - 为了出国交流，跟乒乓球相关的人员都需要学习英语

- 做一个高中学生管理系统，高一，高二，高三
  - 需要做一个抽象的学生类，具体类：高一学生
  - 并且要对学生信息进行增删改查，这就是接口里面的功能，crud工程师



任何时候，先理解记忆，等到后面忘记了，很正常

等到碰到了 再翻笔记，查百度 查博客

没碰到 当不知道

学习不要犹豫 一往无前，学就完事了





> 接口和抽象类形式参数和返回值问题

****

> 方法的形式参数（formal）在传值的时候

**1.基本类型：**对于基本数据类型的方法传参，存在自动类型提升

**2.引用类型：** 对于引用数据类型的方法传参，存在自动向上转型

- 类：调用方法时需要传入的是该类的对象或者该类的子类对象
- 抽象类：调用方法时需要传入的是该抽象类的子类对象
- 接口：调用方法时需要传入的是该接口的子类对象



> 父子类方法重写中，方法声明中返回值类型的书写

**1.基本类型：**必须保持一模一样，不存在类型提升

**2.引用类型：**不必保持一模一样，存在自动向上转型

- 类：父类中的方法返回一个普通类类型
  - 子类方法中可以返回该类型
  - 也可以返回该类的子类类型
- 抽象类：父类中的方法返回一个抽象类类型
  - 子类方法可以返回该类型
  - 也可以返回抽象类的实现类类型
- 接口：父类中的方法返回一个接口类型
  - 子类方法可以返回该类型
  - 也可以返回接口的实现类类型



> 在方法中书写一个具体的返回值

**1.基本类型：**方法体中，返回一个具体的值的时候，存在自动类型提升

**2.引用类型：**方法体中，返回一个具体对象的时候，存在自动向上转型

- 类：返回该类的对象或者该类的子类对象
- 抽象类：返回抽象类的（具体）子类对象
- 接口：返回接口的（具体）子类对象

​	



**C.链式调用**（chain calls）

```java 
StudentDemo sd = new StudentDemo();
Student s = sd.getStudent();
s.show();
//类似这种形式的代码，可以写成链式调用的形式，就变成了
new StudentDemo().getStudent().show();
//结果是一样的
```

```Java
class Student{

    public Student getStudent(){
        return new Student();
    }

    public Teacher getTeacher(){
       return new Teacher();
    }
}
class Teacher{
    public void show(){
        System.out.println("秀一波~~~");
    }
}
```

