# 内部类

[TOC]



> 引入
>
> 我们现在做一个应用程序，需要描述一台电脑（Computer）中的CPU，对于电脑而言
>
> 该怎么去描述这个CPU呢？

- 它有存储设备，IO设备等等很多硬件资源组件
- CPU是电脑中最重要的组件

















> 这个CPU具有以下特点：

- CPU可以调控计算中的所有硬件资源
  - CPU应该设计成一个类，并且是作为一个私有成员存在于计算机内部
- CPU需要被隐藏起来，不能直接暴露在外部，也不能独立于计算机存在
  - 根据我们现在的知识，无法实现这一点
  - 因为声明一个普通类，无法声明为private修饰
- 这个时候就想到能不能直接把CPU类丢到Computer类的内部呢？
  - 这样，有一层壳子，就能够很好的保护CPU
  - 这种嵌套定义的类，就是内部类







> 内部类的定义

- 在Java语言中类可以嵌套定义，内部类（inner class）是定义在另一类当中的类





> 内部类的概述

- 按照内部类在类中定义的位置不同：
  - 定义在成员位置的内部类，称之为成员内部类，普通成员内部类，静态内部类
  - 定义在局部位置的内部类，局部内部类，匿名内部类
- 内部类是典型的，Java从C++中拿过来但是没有经过简化的特性
  - 也就是说Java几乎照搬了C++中的内部类
  - 通过内部类可以稍微感受一下C++的语法复杂性

- 为了上课方便，我们需要统一口径，在内部类课程当中，我们统一规定
  - 像CPU这种类我们称之为内部类（inner class）
  - Computer这种类我们称之为外围类（enclosed class）
  - Demo这种类我们称之为外部类（outside class）



## 成员内部类

> 成员内部类概述

- 成员内部类是最普通的内部类，它定义在另一个类的成员位置， 可以看成该类的一个成员

- 语法

- ```java 
  [访问权限修饰符] class EnclosedClazz{ //外围（普通）类的访问权限修饰符，只有两个，public和缺省
  	[访问权限修饰符] class InnerClazz{//内部类访问权限修饰符，有四个，和普通成员一样
      }
  }
  ```






### 成员内部类自身特点

> 成员内部类自身的特点
>
> 1，访问权限修饰符
>
> 2，成员特点
>
> 3，继承和实现



#### 权限修饰符

> 成员内部类的访问权限修饰符可以是

- public
- protected
- （default）缺省
- private



#### 成员特点

> 成员内部类的成员特点
>
> 成员变量
>
> 成员方法
>
> 构造器

- 可以定义普通成员变量，成员方法
  - 不能定义静态方法、静态成员、静态代码块
  - 可以定义全局常量（因为全局常量是编译时就加入了常量池，不触发类加载）
- 可以定义构造方法，和普通类并无差别



> 成员内部类类加载机制（重要）

- 成员内部类的类加载机制（重要）
- 成员内部类的类加载要靠创建内部类对象触发，因为成员内部类没有静态成员
  - 一个外围类中定义了成员内部类后，并不代表每个外围类对象中都会自动初始化一个内部类对象
  - 只有在外围类对象的基础上，创建内部类的对象，才会触发成员内部类的类加载
  - 也就是说，成员内部类对象依赖于外围类的对象（即成员内部类实例化是在外围类实例的基础上）
    - 任何时候都是这样，即便是反射，也没办法不创建外围类对象而创建成员内部类对象
- **成员内部类对象依赖于外围类对象而存在**



#### 继承和实现

> （了解）成员内部类的继承和实现

- 内部类可以继承和实现外部的类和接口
- 甚至可以在类中定义多个普通类、抽象内部类和接口用来自己继承和实现





### 成员内部类的访问特点

> 成员内部类的访问特点
>
> - 成员内部类内部访问外围类
> - 外围类访问成员内部类成员
> - 外部类访问成员内部类成员
> - 成员内部类访问外部类成员（了解）



#### 成员内部类内部访问外围类

> 需要理解的是，成员内部类相当于外围类的成员
>
> 并且内部类对象依赖外围类，**在成员内部类的成员方法中一定存在一个外围类对象（重要）**
>
> 理解这一点，就好理解下面的现象了

- 成员内部类可以无条件访问外围类的所有成员属性和成员方法（包括private成员和静态成员）

  - 需要注意的是，当外围类中有同名的属性或者方法时，都会发生类似“隐藏”的现象

    - 即默认情况下访问的都是成员内部类的成员

  - 如果要访问外围类的同名成员，需要以下面的形式进行访问：

    - ```Java
      EnclosedClazz.this.成员变量
      EnclosedClazz.this.成员方法
      ```

- 这里有一个类似this、super一样的隐式引用，默认传给成员内部类的所有成员方法
  - 即EnclosedClazz.this
  - 该引用指向了外围类的对象





#### 外围类访问成员内部类成员

> 虽然成员内部类可以无条件地访问外围类的成员，而外围类想访问成员内部类的成员却不是这么随心所欲了
>
> 原因在于内部类访问外围类时，内部类对象和外围类对象一定都已经存在；
>
> 但外围类访问内部类时，内部类对象还不存在，所以必须手动创建内部类对象
>
> 当然如果想要访问内部类中的全局常量，直接内部类名点常量名即可

- 在外围类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象

- 再通过这个内部类的引用去访问内部类的成员

- 在外围类中创建内部类语法：最容易理解，最万能的形式如下：

  - ```Java
    EnclosedClazz oz = new EnclosedClazz();
    InnerClazz ic = oz.new InnerClazz();//该形式适合在外围类中创建内部类
    //或者
    InnerClazz ic2 = new EnclosedClazz().new InnerClazz();//该形式适合在外围类中创建内部类
    ```

  - 如果访问内部类的方法是静态的，则只能使用上述格式，因为静态方法中外围类对象可能不存在

  - 如果访问内部类的方法是普通成员方法，则可以省略创建外围类对象的过程，其语法如下

  - ```java
    InnerClazz ic = new InnerClazz();
    ```

- 在外围类中一旦创建内部类对象，使用该对象可以访问内部类的所有成员，包括私有





#### 外部类访问成员内部类成员

> 外部类要访问内部类成员，条件要苛刻的多
>
> 由于内部类属于外围类的一个成员，所以内部类受访问权限的限制

- 如果该内部类是private修饰，那么显然在任何外部类中都无法访问该内部类成员

- 如果外部类拥有内部类的访问权限，可以创建该内部类对象，来访问该内部类的成员

- 语法

- ```Java
  //该方式最全面，适合任何位置
  EnclosedClazz.InnerClazz ic3 = new EnclosedClazz().new InnerClazz();
  ```

- 和外围类创建内部类对象不同，在外部类中创建内部类对象，不能够访问内部类的私有成员





#### 成员内部类访问外部类成员（了解）

> 在成员内部类中访问外部类成员，和在普通类中访问其它类成员别无二致

- 静态成员直接类名点访问

- 普通成员需创建外部类对象
- 受访问权限控制





> 牛刀小试
>
> 试着说一说下述访问，在成员内部类的情况下，能否进行，怎么进行

- 内部类的成员方法中，去访问外围类的成员（普通或静态、私有成员）

能访问,可以直接访问,外围类的对象已经存在了,也不受访问权限限制

this表示内部类自身对象

外围类类名.this表示外围类对象



- 内部类的成员方法中，去访问外部类的成员（普通或静态、私有成员）

能访问,需要创建对象,受访问权限限制



- 外围类的普通成员方法，访问内部类的成员（普通和全局常量、私有成员）

直接创建内部类对象即可,不受访问权限限制

this表示外围类对象

内部类对象是我们创建出来



- 外围类的静态成员方法，访问内部类的成员（普通和全局常量、私有成员）

不能直接创建内部类对象,因为没有外围类对象支撑,需要先创建外围类对象,不受访问权限限制



- 外部类的普通成员方法，访问内部类的成员（普通和全局常量、私有成员）

先创建外围类对象,然后在此基础上创建内部类对象,注意这整个过程都受访问权限限制

对象创建完之后,访问受权限限制



- 外部类的静态成员方法，访问内部类的成员（普通和全局常量、私有成员）

和普通方法是一样的




## 静态内部类

> 思考：怎么把一个普通成员变成一个静态成员？

- 静态内部类也是处在外围类成员位置的内部类，不同的是它需要使用static修饰
- 语法：

- ```Java
  [访问权限修饰符] class EnclosedClazz{ //外围（普通）类的访问权限修饰符，只有两个，public和缺省
  	[访问权限修饰符] static class InnerClazz{//内部类访问权限修饰符，有四个，和普通成员一样
      }
  }
  ```



### 静态内部类自身特点

> 静态内部类自身的特点
>
> 1，访问权限修饰符
>
> 2，成员特点
>
> 3，继承和实现

- 静态内部类和成员内部类的最大区别就是static关键字

- Oracle公司官网有一段文字解释静态内部类和成员内部类的区别

  - ```Java
    Nested classes that are declared static are called static nested classes. Non-static nested classes are called inner classes.
    ```

- 嵌套的static类就是静态内部类 然后不用static修饰的嵌套类 就是成员内部类
  
- 什么意思呢？解释一下
  
  - 字面意思上看，它在说静态内部类叫做嵌套类，非静态内部类（成员内部类）叫做内部类
  - 什么叫nested呢？
    - 就是直接把一个类丢到另一个类中，本来我和你没有太多的关系，我完全有能力独立的自己做一个类
    - 但是我偏做一个”寄居蟹、啃老族“，借外围类的壳子用一用，来隐藏和保护自己(猥琐)
  - 什么叫inner呢？
    - 就是我处在你的内部，是你的一部分，我了解你，我知道你的全部，没有你就没有我
    - 比如心脏和人，CPU和计算机



- 静态内部类的类加载机制（重要）
  - 静态内部类是独立存在于外围类中的
    - 创建外围类对象，不会触发静态内部类加载
    - 创建静态内部类对象，也不会触发外围类的类加载
    - 静态内部类创建对象不依赖于外围类
  - 类加载的过程对于内部类和外围类是完全独立的





#### 访问权限修饰符

> 静态内部类的访问权限修饰符可以是

- public
- protected
- （default）缺省
- private



#### 成员特点

> 静态内部类的成员特点
>
> 成员变量
>
> 成员方法
>
> 构造器

- 静态内部类可以创建普通类可以创建的所有成员，包括静态
- 体现了静态内部类的独立性



#### 继承和实现（了解）

- 静态内部类的继承与实现和成员内部类并没有太大不同
- 区别在于，静态内部类只能继承一个静态内部类，而不能继承普通类





### 静态内部类的访问特点

> 静态内部类的访问特点
>
> - 静态内部类内部访问外围类
> - 外围类访问静态内部类成员
> - 外部类访问静态内部类成员（了解）
> - 静态内部类访问外部类成员（了解）







#### 静态内部类内部访问外围类

> 静态内部类创建对象的时候，完全可能没有外围类对象
>
> 理解这一点和成员内部类的不同，就好理解下述现象了

- 静态内部类只能直接访问外围类的静态成员，包括私有
- 静态内部类如果想要访问外围类的普通成员，需要创建对象
  - 和一般类创建对象访问成员不同的是，静态内部类中创建外围类不受访问权限限制
- 静态内部类中不存在一个外围类对象的引用，该对象完全可能不存在
- 如果想要调用外围类中，和静态内部类同名的静态成员，只需要外围类名点成员即可
- 如果想要调用外围类中，和静态内部类同名的普通成员，只需要创建外围类对象，对象点即可





#### 外围类访问静态内部类成员

> 静态内部类是相对外围类独立的类，在外围类中访问静态内部类成员
>
> 除了不受访问权限限制外，和访问其他一般类并无差别

- 如果访问静态内部类中的静态成员，可以直接内部类名点，不受访问权限限制

- 如果访问静态内部类中的普通成员，需要创建内部类对象，不受访问权限限制

  - 在外围类的任何地方创建静态内部类对象，都可以用以下语法

  - 最大的区别是不需要创建外围类对象，因为是相互独立的

  - ```Java
    InnerClazz ic = new InnerClazz();
    ```





#### 外部类访问静态内部类成员

> 静态内部类在外部创建对象，可以完全独立于外围类对象，不会触发外围类的类加载

- 创建静态内部类对象
  - 语法

  - ```Java
    EnclosedClazz.InnerStaticClazz ecisc = new EnclosedClazz.InnerStaticClazz();
    ```

  - 和普通类对象访问成员一样，受访问权限限制

- 访问静态成员，无需创建对象，直接

  - ```Java
    EnclosedClazz.InnerStaticClazz.静态成员名
    ```

  - 受访问权限限制



#### 静态内部类访问外部类成员（了解）

> 在静态内部类中，访问外部类成员，和在普通类中访问其他类成员别无二致

- 静态成员，类名点直接访问
- 普通成员需创建对象访问
- 受访问权限控制





> 牛刀小试
>
> 试着说一说下述访问，在静态内部类的情况下，能否进行，怎么进行

- 内部类的成员方法中，去访问外围类的普通成员（包括私有）

创建外围类对象,然后随便防风网

- 内部类的成员方法中，去访问外围类的静态成员（包括私有）

直接类名点访问,不受访问权限限制

- 外围类的普通成员方法，访问内部类的成员（属性和方法包括私有成员）

创建对象然后随便访问

- 外围类的静态成员方法，访问内部类的成员（属性和方法包括私有成员）

创建对象然后随便访问










## 局部内部类

> 局部内部类是定义在一个方法或者一个作用域里面的类
>
> 它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内
>
> 将局部内部类看成是局部变量即可



### 局部内部类自身特点

> 局部内部类自身的特点
>
> 1，访问权限修饰符
>
> 2，成员特点
>
> 3，定义位置
>
> 4，继承和实现



#### 访问权限修饰符

- 局部内部类和局部变量一样，没有访问修饰权限，因为毫无意义，大括号已经限制了它的访问范围

- 局部内部类不能用static关键字修饰，原因和局部变量一样

  

#### 成员特点

- 局部内部类内部无法定义静态成员，局部内部类中也没有静态的概念
  - 其余变量和方法都是可以创建的
- 构造方法和普通类一致，用来给自身成员赋值
- 和成员内部类的成员特点是一致的



#### 定义位置

> 几乎所有的局部位置都可以使用局部内部类
>
> 包括但不限于

- 方法
- 代码块
- if分支
- for循环内部

- 局部内部类的作用：当我们在局部位置，碰到了一个麻烦的问题，需要使用类来解决
  - 但是又不希望这个类被外界知道，这种情况需要使用局部内部类
- 局部内部类在使用前要有合适的理由，不然会自找麻烦





### 局部内部类的访问特点

> 前提：
>
> - 局部内部类相当于方法的局部变量，只在方法内部生效
>
> - 要想触发局部内部类的类加载，必须在该方法内部创建该内部类对象才可以

- 若该方法是普通成员方法
  - 该局部内部类，可以无条件访问，外围类的所有成员 (原因是普通成员方法隐含this 已经有外围类对象了)
  - 局部内部类和局部变量一样，出了作用域就失效了
  - 在外围类中无法创建对象，外部类更不行，只能在方法内部创建实例
- 若该方法时静态成员方法
  - 该局部内部类，可以无条件访问，外围类的所有成员，但是需要创建外围类对象（原因是没有this）
  - 局部内部类和局部变量一样，出了作用域就失效了
  - 在外围类中无法创建对象，外部类更不行，只能在方法内部创建实例

- 要想使用局部内部类的功能，必须在该方法内部创建内部类对象，然后调用方法



### 局部内部类注意事项

- 值得注意的是：
  - Java8之前的版本中，局部内部类只能访问方法中加了final的局部变量
    - 局部内部类对象的生命周期和局部变量的生命周期是有冲突的（life cycle）
      - 局部内部类对象的有可能比局部变量存活更久
    - 为了解决冲突，JVM偷偷的帮我们把局部变量塞到了局部内部类对象的成员中了
    - 但是问题仍然存在，将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的
      - 也就是如果我们在内部类中修改了成员变量，方法中的局部变量也得跟着改变
      - 最终Java开发者选择了妥协，使用final标记局部变量，这样就不能够改变它的值了
  - Java8以后的版本，仍然也是这么做的，但是将final关键字隐藏在底层代码中了
    - 也就是说，底层代码仍然会给局部变量加final
    - 拥有局部内部类的方法的局部变量仍然是final修饰的
    - 只不过从显式变成了隐式
- 局部内部类最大的优势是对方法外部完全隐藏，除了方法本身，即便是当前类也不知道它，不能访问它
  - 这是一种极致的封装思想的体现

- **匿名内部类和lambda本质依然是局部内部类，这一条注意事项仍然生效**



### 局部内部类的经典使用

> 写方法返回接口或者抽象类的具体子类

```Java
class Enclosed3Clazz{
    public A getA(){
        class AImpl implements A{
            @Override
            public void test() {
            }
        }
        return new AImpl();
    }
}
interface A{
    void test();
}
```



> 鸡刀小试
>
> 补全程序，使得可以输出三个num

```Java
class Outer {
    public int num = 10;
    class Inner {
        public int num = 20;
        public void show() {
            int num = 30;
            System.out.println();
            System.out.println();
            System.out.println();
        }
    }
}
```







## 内部类的优缺点和使用场景

> 写在后面的话
>
> Java 1.1版本就引入了内部类（原属于C++）的概念，虽然很多人觉得内部类的引入让Java程序的扩展性提升了
>
> 但也有很多人觉得内部类的引入违背了Java简化C++的初衷，因为内部类的语法过于复杂
>
> 以至于让人提不起兴趣去使用，那么这样看似精致巧秒、实则复杂没必要的设计，到底有什么意义呢？
>
> 这个问题大家可以自己去思考，接下来我们讲几个内部类的使用场景以及内部类的缺点

- 场景一：无条件地访问外围类的所有元素（优点）
  - 无论是成员内部类、静态内部类、局部内部类还是匿名内部类都可以无条件访问
- 场景二：隐藏类
  - 可以用private、protected修饰类
  - private修饰成员内部类、提供public的创建对象方法
- 场景三：实现多继承
  - 可以创建多个成员内部类继承外部多个类
  - 然后创建内部类对象，实际上就是外围类继承了多个类的成员
- 场景四：通过匿名内部类来优化简单的接口实现/lambda表达式更简洁
  - 重点：内部类要说使用频率 最高的肯定是匿名内部类

> 内部类的缺点

- 内部类的缺点也是显而易见，语法很复杂，在类中定义内部类也会导致类的结构变复杂，影响代码可读性
  - 除此之外，不合理使用内部类还可能导致内存泄漏（了解）
    - 如果当内部类的对象被外围类以外的其他类引用时，就会造成内部类和外围类无法被GC回收的情况
  - 内部类就应该给外围类用，不需要给外部类用，给它用是有风险的

# 

