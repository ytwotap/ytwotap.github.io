# static 关键字

> static关键字是我们从”hello world“开始，就频繁使用的一个关键字
>
> 例如我们的main方法，例如我们一直在写的static方法

- 但是我们经常用，却不知道为什么这么用
- 那么今天就正式学习static关键字

​	



- 引例

```Java
练习：
	创建一个学生类，用来描述我们班全体同学，要求
		属性：姓名，性别，年龄，学号，学校信息
		行为：吃饭，学习
```

- 建议性别用gender，禁止使用布尔类型的isMale，isFemale这种形式
- 创建多个学生对象，想一想会有什么问题？



















> 对于我们班级的同学来说，学校名字都是固定的“王道训练营”
>
> 我们虽然知道这一点，但是我们还是要，不厌其烦的在每次创建对象的时候，给schoolName赋值
>
> 这显然是没有必要的，浪费时间的同时也浪费内存空间

- 怎么改进这个设计？
  - 可以把成员变量schoolName中直接初始化赋值为“王道训练营”，这样可以实现功能
  - 但是每个对象中都存有一个成员变量，浪费空间
  - 最重要的，我们在设计类的时候其实已经知道这个属性，是全体对象都有的
    - **我们希望这个属性不是属于某一个对象的，而是一种类的特征，是属于类的，属于全体对象的**

- 上面这个改进不是我们最希望的样子
  - 那么能不能在内存中找一块区域，每个对象都共用这片区域，把schoolName放进去？
  - 这样做既节省时间，又节省空间
  - 最重要的体现了该属性属于类——只要是这个类的对象都该有这个属性













> 在JVM内存的设计当中，确实在方法区中开辟了一块单独的空间
>
> 用于存放这些 “所有对象共享，整个类的对象都只有一份的数据”
>
> 在Java当中把存放在这个区域的成员，称之为静态成员，包括静态成员变量和静态成员方法

```
语法：
	1，成员变量在数据类型前加static，静态成员变量或者简称静态变量
	2，成员方法在返回值类型前加static，是为静态成员方法或者简称静态方法
```

- 修改一下schoolName为static修饰，验证一下该成员是否成为所有对象共享

- 很容易就可以验证出这一结果，那么接下来，我们结合我们的内存图去深入的学习static关键字















> 接下来我们通过一个案例来深入了解static关键字
>
> 宠物公司新进了一批同样颜色的宠物，创建一个类描述这批宠物
>
> - 属性：颜色，性别
> - 行为：（static）跑，吃







> 总结static

- static修饰成员，称之为静态成员，包括静态成员变量和静态成员方法
- <font color=red>随着类加载完毕，静态成员就存在，并且能够使用了</font>
  
  - 静态成员变量在类加载过程中完成初始化，并且具有默认值
  - 静态成员方法的二进制指令集合在类加载过程也准备完毕，可以调用了
- 静态成员领先于对象存在，不依赖于对象而存在
  - 静态成员变量在创建对象之前就已经创建了
    - 类加载的时候创建，类加载只有一次，所以静态成员也只有一份且被类所有对象共享
  - 静态方法被所有类对象共享，且无需创建对象就能调用
- 仍然可以创建对象去调用静态成员，但是规范的Java代码只建议通过类名直接访问
  - 静态成员变量：类名.变量名
  - 静态成员方法：类名.方法名
  - 对象调用的方式，好像该成员属于对象，但显然静态成员属于全体对象，属于类
- 在很多书籍博客中，由于静态成员的随着类加载而存在的特点
  - 静态成员是该类全体对象共有，属于类
  
  - 所以也称类成员，类属性，类变量，类方法
  
  - 知道这种称呼即可，但是大家还是习惯叫静态成员
  
  - C语言用static定义那些在方法外面也可以使用的局部变量
  
    C++把这个关键字拿来了 但是完全改变了它的含义
  
    Java又拿过来了













> 比较静态成员变量和普通成员变量
>
> 从以下四个角度
>
> - 所属不同
> - 在内存中的位置不同
> - 在内存中出现时间不同
> - 调用方式不同
>
> 成员方法的区别也类似

- 所属不同
  - 静态成员变量属于类，所以也称为为类变量
  - （普通）成员变量属于对象，所以也称为对象变量（对象变量）
- 在内存中的位置不同
  - 静态变量存储于方法区的静态区，被所有对象共享
  - 成员变量存储于堆内存，每个对象独享自己的成员变量
- 在内存中出现时间不同
  - 静态变量随着类的加载而加载，比成员变量出现的要早
  - 成员变量随着对象的创建而存在
- 调用方式不同
  - 静态变量可以通过类名调用，也可以通过对象调用（不推荐/不合理的方式）
  - 成员变量只能通过对象名调用，必须创建对象

> 静态成员方法和普通成员方法的区别和上述类似











> 那么我们使用static的场景是什么？

- static的使用场景
  - 静态成员变量：当存在需要所有对象共享的变量时，应该使用static
  - 静态成员方法：当不需要对象只是需要便捷的调方法时，使用static，广泛应用于工具类中，方便访问调用
    - 数组工具类



​		

​	



> 注意事项：

- 一个类中，静态方法无法直接调用非静态的方法和属性，也不能使用this，super关键字
  - 经典错误：Non-static field/method xxx cannot be referenced from a static context
  - 原因：静态方法调用的时候，可能还没有对象，直接访问属于对象的成员变量和成员方法显然不合适
- 反过来，一个非静态的方法，可以访问静态的成员
  - 因为有对象的时候，一定有静态成员
  - 建议采用这种访问形式的时候，使用类名.变量名的形式访问，以示区别，增加代码可读性
- 只存在静态成员变量，不存在“静态局部变量”
  - 局部变量只有在调用的时候才有意义
  - 而静态变量在类加载时就初始化，就存在了
  - 如果我一直不调用这个方法，这个“静态局部变量”就一直占着空间，没有意义
- 静态方法是类所有，那么静态方法的局部变量就也是类所有，为什么静态方法中也不能有静态局部变量？
  - 局部变量一定是方法所有
  - 静态方法也是方法，不调用其中的局部变量也没意义
- 静态成员变量不建议用构造方法赋值
- 普遍来说，访问静态成员，都建议加上类名去访问，提升代码可读性

​	



> 牛刀小试

- 请说明程序的输出结果

```Java
public class Demo {
    static Cat cat = new Cat(); 
	Dog dog = new Dog();
	Dog dog2;

    public static void main(String[] args) {
        System.out.println("hello world!");
        Demo d = new Demo();
    }

    public Demo() {
        System.out.println("demo");
    }
}

class Cat {
    static Dog dog = new Dog(); //static3 int a = 10;

    public Cat() {
        System.out.println("cat");
    }
}

class Dog {
    public Dog() {
        System.out.println("dog");
    }
}
```