# 多态的访问特征

> 发生多态后，通过引用调用成员的方式发生了改变
>
> 父类 引用 = new 子类();

- 对于成员变量而言
  - 编译时看左边，运行时看左边
  - 也就是说成员变量是没有“多态”的（因为多态的前提就是发生方法重写）
  - 多态现象是发生在方法之间，和成员变量没有关系
- 对于成员方法而言
  - 编译时看左边，运行时看右边

> 解释
>
> 父类 引用 = new 子类();

- 编译看左边
  - 编译看左边是说通过引用变量可以访问到的子类成员的范围
    - 是由引用类型来决定的，也就是说由父类中定义的成员决定
  - 我们只能通过引用去访问，堆上的对象，引用中必然装有该类型对象的成员信息
  - 只有通过引用变量，我才能访问到堆上的对象
    - 也就是说，对象的访问受限于引用变量本身的类型



> 解释方法的多态性，一个很贴切的例子

- 我家中的一台电视机，贼贵，功能很丰富
- 对于电视机而言，我们只能使用，遥控器去操作电视机
- 这也就是说，只有遥控器上提供的功能我们才能使用
  - 即便电视机本身功能多么强大，如果遥控器上只有音量键，那我们也毫无办法
  - 遥控器有啥功能，决定了我们能使用的功能
- 即使电视机本身功能再丰富，没有遥控器的支持，我们啥也用不了

> 把这个例子转换到Java程序中

- 电视机就相当于对象本身，而遥控器就是引用变量
- 实际对象的功能再强大，如果引用中没有这个功能，那也无法调用该功能
- 对象的行为，受限于引用变量，和对象本身没有直接关系
- 对象的引用类型决定了可以访问对象的成员范围
- 编译时看左边，运行时看右边





> 解释成员变量不具有多态性，一个例子

- 成员变量描述的是对象的“外貌特征”
- 把子类对象赋值给父类类型的引用，就相当于给子类对象披上了一个父类类型马甲
- 外貌特征上来看，这时候的子类就变成了父类
- 编译时看左边，运行时看左边

​	
