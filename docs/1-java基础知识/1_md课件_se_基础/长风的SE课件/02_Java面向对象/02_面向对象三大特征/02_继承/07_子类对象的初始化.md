# 子类对象的初始化（initialization）

> 子类继承了父类，子类中就包含了父类的成员
>
> 那么在创建初始化子类对象时，和之前相比也会有较大的不同



- 练习
  - 创建一个Person类，有name属性和eat方法
  - 创建一个Star类，有stageName属性和sing方法
  - Star类要继承Person类
  - 创建Star类对象，画出这个过程的内存图



> 子类创建对象过程

- JVM仍然是创建谁的对象，就加载谁，先加载子类
- 但是很快，在子类还没有加载的时候，JVM发现子类有父类
  - 父类如果不存在，子类肯定也不可能存在
- 于是JVM调转枪头，开始加载父类
- 加载完父类，再加载子类
- 类加载都结束后，开始创建堆上的对象
- 堆上的对象中，会有一片空间，用来存放父类的成员
  - 子类对象就由两部分组成
  - 一部分是子类自己独特的成员
  - 另一部分是从父类继承过来的成员
- 现在堆上就真实存在了一个子类对象
  - 子类对象中存放父类成员的内存区域，可以近似的看成是一个父类对象
  - 所以子类的内存图，近似看成子类对象“装着”父类对象
  - 注意，**这个父类对象只是近似看作，不会真的创建了父类对象**
    - 创建子类对象，只会类加载父类，不会真的创建父类

> 子类对象创建到这里，已经进入尾声了，但是我们仍然有一个棘手的问题

- 子类对象中的，父类成员变量和子类自身成员变量，谁先初始化默认初始值和赋值？
  - 答：先给父类成员变量默认初始化，再默认初始化子类
  - 为什么？答：先父后子，没毛病，首先要有父亲，才有儿子
  - 其次，子类成员变量的初始化，可以依赖父类成员变量
    - 这个时候如果子类先初始化，显然是要报错的





> 至此，我们的子类对象就创建完毕了
>
> 但是我们的问题仍然没有结束

- 子父类的类加载顺序是由JVM去保证的，但是子父类的初始化先后顺序又是怎么保证的呢？
- 它的原理是什么呢？

> 我们已经知道了构造器是可以用来初始化成员变量，会由JVM自动调用
>
> 用构造器去保障这种先后顺序，怎么做呢？

- 答：只需要在子类的构造器的第一行，调用父类构造器就可以了





> 我们没有自己手动在子类构造器的第一行，调用父类构造器，但是仍然达成了先初始化父类
>
> 再初始化子类的效果，是什么原因呢？
>
> 显然这里存在了一个隐式调用，于是子类对象的初始化就有了两种方式

- 隐式的调用了父类构造方法（JVM保证）
- 程序员显式的调用父类构造方法（代码保证）
