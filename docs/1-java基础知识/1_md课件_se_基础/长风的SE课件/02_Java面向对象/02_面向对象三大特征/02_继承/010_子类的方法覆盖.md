# 子类的方法覆盖（override）

> 子父类中能否拥有同名的方法呢？
>
> 如果可以，请尝试

- 在父子类中声明两个个一模一样的方法，但是方法体输出不同
  - 创建子类对象，直接调用该方法，结果是什么呢？
- 再在父子类中定义两个方法，分别在方法体中调用自身方法名一样的方法
  - 创建子类对象，分别调用两个方法，结果是什么呢？
- 我们发现无论怎么操作，都只能访问子类中的同名方法，这就是方法的覆盖



> 用对象名点成员方法的方式来调用成员方法，它的编译器检索机制和访问成员变量类似

- 编译器会先从引用的类型中查找，查找不到就去父类中查找，再找不到就会报错
- 所以说对于用对象名点访问成员这种方式，编译时期能够访问的成员都是根据父类来定的



> 但是调用方法时，没有办法在编译时期就确定调用哪个方法，需要程序运行时才能确定

- 程序运行起来，方法会表现出对象的真实类型的行为，如果子类访问父子类同名方法就体现为方法覆盖





> 如果想在子类的方法中，访问父类同名方法，应该怎么办？

- super关键字







> 什么时候使用方法的覆盖？

- 当我们需要在子类中，修改父类方法的实现的时候
- 使用方法的覆盖时，添加@Override注解来标记
  - 例如：比如对于动物的叫，人类的吃



> 方法覆盖的注意事项

- 父类中私有方法不能被重写
- 子类重写父类方法时，访问权限不能更低
- 静态方法在使用现象上，很像是被重写了，但实际上静态方法不能被重写，而是直接是一个新的静态成员





> 继承练习： 猫狗案例
>
> 猫狗都有品种（breed），名字，年龄的属性
>
> 行为上都有吃，叫的方法
>
> 但是猫可以抓老鼠，狗可以看门



- 重写 VS 重载

|              | 重载（overload） |                      重写（override）                       |
| :----------: | :--------------: | :---------------------------------------------------------: |
| 发生的类不同 |   发生在同类中   |               发生在子父类之间,肯定不是一个类               |
|    方法名    |     必须相同     |                          必须相同                           |
|   参数列表   |     必须不同     |                          必须相同                           |
|  权限修饰符  |      不影响      |            重写的方法访问权限必须大于等于原方法             |
|     异常     |      不影响      |                重写的方法不能抛出更多的异常                 |
|  返回值类型  |      不影响      | 重写的方法的返回值类型必须和原方法兼容,代表可以不是完全一致 |

- 被static、final、private修饰的父类方法无法被重写



