# 补充protected

> 回顾一下protected关键字，四个等级的访问权限



对于类中成员的访问权限控制，访问权限控制符总位于定义的开头位置，可以使用的修饰符有4种：

​	1，public：任意类均访问，实际就是没有限制访问权限

​	2，protected：同包中的其他类，和不同包的(可见)子类均可见，一部分类可以访问到，一部分不行。

​	3，(default)(默认权限，隐式定义，不写任何关键字)，同包中的其他类可见，不关心是不是子类

​	4，private，仅对同类中的其他成员可见

|              | public | protected | 默认 | private |
| ------------ | ------ | --------- | ---- | ------- |
| 同一类中     | √      | √         | √    | √       |
| 同一包其他类 | √      | √         | √    |         |
| 不同包子类   | √      | √         |      |         |
| 不同包其他类 | √      |           |      |         |



> 定义上含糊的说了，protected在不同包的子类中可以访问
>
> 但实际上不同包的子类，仍然可以细分

- 不同包的子类中，创建父类对象，用父类对象访问protected成员
- 不同包的子类中，创建子类对象，用子类对象访问protected成员
- 不同包的子类中，创建该类的其他子类对象，用这个其他子类对象访问protected成员













> 最终我们得出结论
>
> protected四个等级的访问层次

- 同类中，可以任意访问
- 同包的子类或其它类中，始终都是可以访问该类的protected成员
  - 在同包的子类或其他类中，创建该类对象，可以访问该类的protected成员
  - 在同包的子类中，创建当前类子类对象，可以访问该类的protected成员
  - 在同包的子类或其他类中，创建该类不同包的子类对象时，可以访问访问该类的protected成员
- 不同包的子类中，分情况
  - 创建父类对象，无法访问，该类的protected成员
  - 创建当前类子类对象，可以访问，该类的protected成员
  - 在该子类中创建另一个子类的对象，无法访问，该类的protected成员
  - **不同包的子类中，只有在子类中创建自身子类对象，才能访问从父类那里继承过来的，protected成员**
    - **其他情况都不行，如创建父类对象，子类中创建别的子类对象等**
- 不同包的其他类中，始终都不可以访问该类的protected成员
  - 创建该类对象，不可以访问该类的protected成员
  - 创建该类的子类对象，不可以访问该类的protected成员





> 怎么总结protected的访问权限

- 简单版本

  - 同类中，同包中，都可以任意访问（创建父类对象，子类对象都可以）
  - 不同包的时候，必须在子类的那个类中，创建当前子类的对象才可以访问
    - 创建别的子类对象，不能访问
    - 创建父类对象，不能访问

  - 子类只能在自己的作用范围内访问自己继承的那个父类protected域
    - 而无法到访问别的子类（同父类的亲兄弟）所继承的protected域和父类对象的protected域
  - 说白了，子类继承自父类的protected成员，必须自己来处理，爸爸帮不了，兄弟姐妹更帮不了
    - 这是出于安全机制考虑，避免滥用受保护机制





> 要用对象名调用一个继承自父类protected成员时，应该怎么思考能不能访问？

- 首先考虑是否同类，同包，如果同类或同包，创建父类对象，子类对象，必然都可以访问
- 如果不同包，考虑是否是子类中，如果不在子类中，无论创建什么对象，必然都不可以访问
- 如果在不同包的子类中，考虑调用protected成员的对象性质
  - 如果使用的对象是父类对象，必然不可以访问
  - 如果使用的对象是子类对象，仍然要考虑
    - 如果该子类对象就是当前类的对象，可以访问
    - 如果该子类对象不是当前类的对象，不可以访问

​		





> protected设置的这么复杂，有什么意义？

- 如果没有继承，那么public、private两个权限修饰符足够我们使用了
- 但是有了继承后，如果类中某个成员，非常有价值，我们希望这个成员总是被子类使用，而不会被滥用
  - 使用protected修饰成员以后，一定能够保证该成员被子类所用
    - 还能保证子类只能用自己继承的
  - 使用protected限制该成员，能够保证子类拥有对自己继承的protected成员最大的权限
    - 想想父母的财产，也不会随便就交给一个陌生人。而是希望交给子女吧？
    - 想想子女继承了父母的财产，它们就拥有了最大的权限，七大姑八姨就不能使用这个遗产
    - 但是子女如果允许，仍然可以让别人使用他继承过来的遗产（成员）
      - 叫做子类重写父类protected成员的访问修饰权限 ----> public



>  Demo和Test都继承了Object类中的protected修饰的成员方法clone()

- Demo类中创建Demo类对象，叫当前子类中创建当前子类的对象
- Test类中创建Demo类对象，叫当前子类中创建其他子类的对象

```java
public class Demo {
    //Demo类继承了Object 继承了clone()
    public static void main(String[] args) throws Exception {
        Demo demo = new Demo();
        demo.clone();
        /*Object o = new Object();
        o.clone();*/
    }

}

class Test{

    public static void main(String[] args) {
        Demo demo = new Demo();
        //demo.clone(); 'clone()' has protected access in 'java.lang.Object'
    }
}
```


