# ⑧值传递和引用传递

[TOC]

---



## 1. 基本概念

> 调用方法时，我们需要传递实参给方法，在方法内部会改变这些实参的值，那么方法执行完毕后
>
> 这些实参的值会怎么变呢？
>
> 首先介绍两种值传递的方式

- 值传递（call by value），指的是调用方法时，传入的是实参的拷贝而不是实参本身
  - 这样做的结果是，方法改变的是实参拷贝的值，原本实参的值是不会变的
- 引用传递（call by reference），指的是调用方法时，传入的是实参的变量地址
  - 注意，基本数据类型也是有地址的
  - 这样做的结果，方法改变的是实参本身的值，原来实参的值会跟着变化

> Java到底是哪一种传递模式？又或者对基本数据类型是值传递，对引用类型是引用传递？
>
> 对于这个问题，首先要搞清楚一些概念

- 引用数据类型和基本数据类型的区别
  - 基本数据类型，值就直接保存在栈上的变量中
  - 引用数据类型，栈上变量保存的是堆上对象的地址，也就是引用
- 赋值运算符“=”的作用
  - 基本数据类型，赋值符号会直接覆盖原本的值，原先的值就没了
  - 引用数据类型，赋值符号会直接覆盖引用中原先保存的地址值，原先的地址被覆盖掉
    - 注意，原先引用地址所指向的对象不会发生变化（重点）



## 2. Java的值传递

> 实际上严格来说，Java只存在值传递，方法得到的是变量的拷贝，而不是变量的地址

- 对于基本数据类型而言，方法调用过程如下
  - 在调用的方法的栈帧中初始化一个实参的副本
  - 对这个副本进行操作，原先main方法栈帧的变量的值不会发生变化
  - 并且这个方法执行完毕后，随着方法出栈，这个实参的副本也被销毁了
- 对于引用数据类型而言，方法调用过程如下
  - 在调用的方法的栈帧中声明一个引用的拷贝，因为是拷贝，所以这个引用中存的内存地址和原先的引用一样
    
    - 结果就是，这个副本仍然指向了原先引用所指向的对象
    
  - 对这个引用的副本进行操作，原先main方法栈帧的引用不会发生变化，但由于指向的是同一对象
    
    - 结果就是，引用和引用拷贝指向的对象本身被改变了
    
  - 方法结束后，这个引用拷贝也被销毁了
  
    



## 3. 证明Java值传递

> 很多程序语言（尤其是C/C++）提供了两种传参方式，导致很多人也认为Java也是两种传参方式
>
> 这里举一个反例

- 声明初始化两个数组

- 提供一个交换数组的方法swap

  - ```java
    public static void swapArray(int[] arr1,int[] arr2){
        int[] temp;
        temp = arr1;
        arr1 = arr2;
        arr2 = temp;
    }
    ```

- 方法的调用过程如下

  - 首先在调用方法的栈帧中声明两个数组的引用拷贝，仍指向原先的数组
  - 交换这两个拷贝的值，实际上就是交换它们指向的数组，这里两个拷贝完成了数组交换
    - 原先的数组引用不受影响
  - 方法结束后，这两个引用拷贝被销毁



## 4. 总结

> 总结：Java方法对方法参数能做什么？

- 不能修改基本数据类型的参数的值（局部变量）
  - 实际开发中也不会真的有让你把基本数据类型通过方法去改变
- 可以改变引用数据类型中对象里的数据（称之为改变对象的状态，改变对象的属性值）
- **无法直接改变参数引用所指向的地址（引用指向的对象）**





## 5. 启示

> 写在最后
>
> 不要纠结概念，Java到底是什么传值方式？即便是到了今天，仍然会有人在网络上争吵
>
> 有些人会说：Java方法传值的本质是值传递不错，但是对于引用类型，确实可以改变对象里的数据
>
> 应该叫引用传递。所以Java是值传递和引用传递共存，表面有引用传递，本质是值传递

- 不要和喷子和钢筋对线，就告诉他们他们是正确的
- 理解本质，关注原理
- 概念是死的，思想是活跃的
