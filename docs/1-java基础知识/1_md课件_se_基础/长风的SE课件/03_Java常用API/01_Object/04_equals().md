# equals()

> public boolean equals(Object obj)
>
> equals() 概述

- 语法

  ```Java
  对象名.equals(其他对象名)
  ```

- 指示其他某个对象是否与此对象“相等”
  - 此对象：调用equals() 方法的对象
  - 其他某个对象：equals() 方法括号中的对象
- 对象相等的含义
  - 我们理想状态下的对象相等
    - 首先两个对象的类型要相同，如果类型都不想同，那就没有意义了
    - 类型相同的情况下，比较成员变量的取值是否相等，都相等则认为两个对象相等
  - Object类中的相等
    - 只有两个对象的内存地址相等，才叫相等
    - Object类中的equals()方法等价于”==“
    - 对象存在堆上没有办法直接拿出来比，于是”==“比较的是两个对象的引用
    - 两个引用变量是否相等，取决于它们是否指向了同一对象，也就是比较对象的内存地址
  - Object类中的equal()方法不能满足我们需求，需要自己手动重写该方法



> 设计equals() 方法的原则（常规协定）

- 自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true
- 排他性：当比对的不是同种类型的对象或者是一个null时，默认返回false
- 对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true
- 传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true
  - 那么x.equals(z) 应返回 true
- 一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false
  - 前提是对象上equals 比较中所用的信息没有被修改
- 其实只要按照下述原则重写，就能够满足上面的常规协定
  - 若是不同类型的对象，直接认定不相等
  - 若是相同类型的对象，认为具有相同的成员变量的两个对象，才是相等的





> 判断是否是同种类型对象的两种方式：
>
> 当传入一个o作为被比较的对象时

- if ( ! (o instanceof 当前类) )
  - 当使用instaceof关键字时，o可以传入后面类型的对象，也可以是子类对象
- if (o == null || this.getClass()  !=  o.getClass())
  - 当使用getClass()方法的运行时类型判断时，必须要求传入一致类型的对象



> equals方法使用注意事项：

- 对于任何非空引用值 x，x.equals(null) 都应返回 false
- 不要使用一个null常量去调用方法，会引发程序错误，报空指针异常
  - 在方法中，我们只能对方法的参数进行校验，没办法校验调用者
  - 应该在外部写代码，防止使用一个null去调用方法
- 如果类中有引用类型的成员变量，继续调用该引用类型的equal()方法判断





> 补充知识点：

- 浮点类型比较大小，不建议直接使用“=”号，而是用Double类和Float类中的compare() 方法
  - 调用方式：Double.compare(doule d1,double d2)   Float.compare(float f1,float f2) 
  - 判断方式
    - 如果这两个数字数学意义上相等，则返回 0
    - 如果前者在数字上小于后者，则返回小于 0 的值
    - 如果前者在数字上大学后者，则返回大于 0 的值



- 财务金额上使用的确保精度的数字类型
  - 如果使用double或者float作为金额的数据类型，会出现一些不可预知的精度问题
  - 推荐使用BigDecimal这个类
