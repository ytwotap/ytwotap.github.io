# finalize()

> 方法的源代码

```java
protected void finalize()  throws Throwable {  }
```

- Object()类当中的finalize()方法是protected权限，并且是空的
- 完全可以看得出来，该方法需要子类自己重写去实现功能
- 这种方法比接口的抽象方法要自由，因为它不是强制的



> 该方法的调用时机和功能

- 当一个对象成为匿名对象，不存在任何引用指向它时

  - 它就成为了一个垃圾对象

- Java的垃圾回收器就开始准备回收该对象，释放内存空间

- 但是垃圾回收器只能回收Java相关的内存空间（new出来的对象）

  - 那些该对象获取的特殊内存空间（非Java的系统资源）垃圾回收器无法直接回收
  - 于是调用该方法去释放一些和Java没有关系的系统资源（需要子类重写）
    - 这里需要子类重写finalize()才能达到效果
    - JVM在回收new对象空间之前会自动调用finalize方法，并且只会调用一次
  - 比如说对象调用的IO资源，调用native方法开辟的空间等等
    - Scanner

- 整个垃圾回收期间，只会被调用一次

- 综上

  > 一旦垃圾收集器准备释放对象占用的存储空间，将首先调用其finalize()方法，进行一些必要的清理工作
  >
  > 在调用该finalize()方法释放其他资源后，jvm会再一次的执行检查该对象是否还存在其他引用
  >
  > 并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存（new出来的对象）
  >
  > 所以可以在子类中重写该方法，然后作为释放对象持有其他资源的手段



> 总结：

- finalize()方法是典型的Java拿来C++机制想要使用，但是失败的案例
  - C++析构函数是指对象在销毁前自动执行的方法，是为了给对象的销毁做最后的收尾工作
  - 比如释放系统资源（这里显然C++胜出）
- 但是Java的垃圾回收机制不是手动的，而是自动的。对象的销毁，垃圾回收具有不确定性
- 而只有在真正要销毁（new出来的）对象之前才会调用finalize()方法
- 所以使用finalize()给对象销毁做”善后“操作，也是不确定的，不安全的，低效率的
- 所以应该避免使用finalize()方法去释放系统资源，**而是在使用完毕后，手动去关闭这些资源**
- 这是自动垃圾回收便利的代价，你不得不放弃对系统资源释放的控制



> 这玩意没用，但是知道它可以增长见识

- thinking in java 
  - 这本书有一章专门的章节讲对象的生命周期，从对象的创建到销毁
- GC

