

[TOC]





# 问题

**计算机如何进行算数运算 + - * / 4种基本运算** 

通过源码 反码 补码 移码 转换 来 计算 和  比较大小等数字逻辑操作.

**如何将这些基本运算进行控制的**  

ALU:控制器 流水控制?

**如何由基本运算----->我们常见的图像显示.**

图像显示推测: 通过抽象转换形成的 . 代码表示 图像不同显示的颜色. 显示器 解释器 通过解释代码 来分别表示不同的颜色,通过矩阵代码实现 图像的表示 .

但是,你观察上面图像表示的过程中 并没有任何的图像相关的东西 .也就是说 通过 抽象转换替代的方式 ,进行有规律的表示事物,在通过不同的解释 规律 形成 具象的事物.

# 定位运算

定点运算包括移位、加、减、乘、除几种。

## 移位运算

### 移位运算的意义

计算机中小数点的位置是事先约定的，因此，二进制表示的机器数在相对于小数点作n 位左
移或右移时，其实质就是该数乘以或除以γ （ n = 1,2 ，…，n)。

例如， 15 m 可写成1 500 cm ，单就数字而言， 1 500 相当于数
15 相对于小数点左移了两位，并在小数点前面添了两个O ；同样15 也相当于1 500 相对于小数
点右移了两位，并删去了小数点后面的两个0。可见，当某个十进制数相对于小数点左移n 位
时，相当于该数乘以IOn ；右移n 位时，相当于该数除以10no

###### **为啥要移位运算**

移位运算称为移位操作，对计算机来说，有很大的实用价值。例如，当某计算机没有乘（除）
法运算线路时，可以采用移位和加法相结合，实现乘（除）运算。

###### **移位出现的问题**

计算机中机器数的字长往往是固定的，当机器数左移n 位或右移n 位时，必然会使其n 位低
位或n 位高位出现空位。那么，对空出的空位应该添补0 还是1 呢？这与机器数采用有符号数
还是无符号数有关。对有符号数的移位称为算术移位。



### 算数移位的规则

对于正数，由于［ x]ll = [x]~~ = [x]li. ＝真值，故移位后出现的空位均以0 添之。对于负数，
由于原码、补码和反码的表示形式不同，故当机器数移位时，对其空位的添补规则也不同。表6.4
列出了三种不同码制的机器数（整数或小数均可〉，分别对应正数或负数移位后的添补规则。必
须注意的是：不论是正数还是负数，移位后其符号位均不变，这是算术移位的重要特点。

![image-20200513162955663](D:\src\Typora记录\计算机组成原理\images\image-20200513162955663.png)





①机器数为正时，不论是左移还是右移，添补代码均为Oo

②由于负数的原码数值部分与真值相间，故在移位时只要使符号位不变，其空位均添0
即可。测试

```
yuan : 1,101001

fan: 1,010110

buma:1,010110

fan <- 移位 1: 1,101101

yuan<-移位1:  1,010010
```

④分析任意负数的补码可发现，当对其由低位向高位找到第一个“ 1 ”时，在此“ 1 ”左边的各
位均与对应的反码相同，而在此“ 1 ”右边的各位〈包括此“ 1 ”在内）均与对应的原码相同。故负
数的补码左移时，因空位出现在低位，则添补的代码与原码相同，即添O ；右移时因空位出现在高
位，则添补的代码应与反码相同，即添lo



``` 
yuan : 1,101001

fan:   1,010110

buma:  1,010111
buma<-移位1:1,101110
yuan<-移位1:1,010010
```



因6.3 示意了机器中实现算术左移和右移操作的硬件框图。其中，因6. 3( a ）为真值为正的
三种机器数的移位操作；图6. 3 ( b ）为负数原码的移位操作；图6. 3 ( c ）为负数补码的移位操作s
图6.3(d ）为负数反码的移位操作。

![image-20200513165723536](D:\src\Typora记录\计算机组成原理\images\image-20200513165723536.png)



### 算数位移和逻辑移位的区别

有符号数的移位称为算术移位，无符号数的移位称为逻辑移位。逻辑移位的则是：逻辑左移时，商位移丢，低位添O ；逻辑右移时，低位移丢，高位添0。



# 加法与减法运算

加减法运算是计算机中最基本的运算，因减法运算可看做被减数加上一个减数的负值，即
A - B=A +(-8 ），故在此将机器中的减法运算和加法运算合在一起讨论

**。现代计算机中都采用补码作加减法运算。**

## **1. 补码加减运算的基本公式**

![image-20200514155000765](D:\src\Typora记录\计算机组成原理\images\image-20200514155000765.png)

![image-20200514155111753](D:\src\Typora记录\计算机组成原理\images\image-20200514155111753.png)

因此，若机器数采用补码，当求A - B 时，只需先求［“ B＂·］ 补（称［ -B ］~• 为“求补”后的减数），就可按补码加法规则进行运算。**而［ -B ］ 咎由［ B ］＊ 连同符号位在内，每位取反，末位加1而得。**



**在计算机中，这种超出机器字长的现象叫溢出。为此，在补码定点加减运算过程中，必须对结果是否溢出做出明确的判断。**

## 溢出判断

补码定点加减运算判断溢出有两种方法。

### (1 ）用一位符号位判断溢出

**问题:为啥 负数比正数多1 ,** 

在源码中体现不出来 ,在补码中,由于+1,从而使他移位一位,负数为-n- -1   正数为 0 + n-1

由此可得出一个结论：由于“零”在补码中只有一种表示形式，故补码比原码和反码可以多表示一个负数。



### (2 ）用两位符号位判断溢出



## 3.补码定点加减法所需的硬件配置

3. 图6.5 是实现补码定点加减法的基本硬件配置框图。

![image-20200514201300502](D:\src\Typora记录\计算机组成原理\images\image-20200514201300502.png)

![image-20200514201313110](D:\src\Typora记录\计算机组成原理\images\image-20200514201313110.png)

# 6.3.3 乘法运算

在计算机中，乘法运算是一种很重要的运算，有的机器由硬件乘法器直接完成乘法运算，有
的机器内没有乘法器，但可以按机器作乘法运算的方法，用软件编程实现。因此，学习乘法运算
方法不仅有助于乘法器的设计，也有助于乘法编程。

![image-20200515101908001](D:\src\Typora记录\计算机硬件系统设计\image-20200515101908001.png)

改进

**![image-20200515101921262](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200515101921262.png)**



10110101

11001010

改进笔算

![image-20200515105735652](D:\src\Typora记录\计算机硬件系统设计\image-20200515105735652.png)

计算机很容易实现这种运算规则。用一个寄存器存放被乘数，一个寄存器存放乘积的高位，
另一个寄存器存放乘数及乘积的低位，再配上加法器及其他相应电路，就可组成乘法器。又因加
法只在部分积的高位进行，故不但节省了器材，而且还缩短了运算时间。

## **原码乘法**

(2 ）原码一位乘所需的硬件配置

![image-20200515101352788](D:\src\Typora记录\计算机硬件系统设计\image-20200515101352788.png)

图中血、X 、Q 均为n +1 位的寄存器，其中X 存放被乘数的原码， Q 存放乘数的原码。移位和
加控制电路受末位乘数亿的控制（当Qn = 1 时， A 和X 内容相加后， A,Q 右移一位：当QR :0
时，只作A,Q 右移一位的操作〉。计数器C 用牙控制逐位相乘的次数。S 存放乘积的符号。GM
为乘法标记。



### **流程控制**



乘法运算前， A 寄存器被清零，作为初始部分积，被乘数原码在X 中，乘数原码在Q 中，计数
器C 中存放乘数的位数n。乘法开始后，首先通过异或运算，求出乘积的符号并存于S ，接着将被
乘数和乘数从原码形式变为绝对值。然后根据Q魄的状态决定部分积是否加上被乘数，再逻辑
右移一位，重复n 次，即得运算结果。

![image-20200515110534720](D:\src\Typora记录\计算机硬件系统设计\image-20200515110534720.png)





上述讨论的运算规则同样可用于整数原码。为了区别于小数乘法，书写上可将表6.9 中的
仁”改为“，”。
**为了提高乘法速度，可采用原码两位乘。**

## 原码两位乘法

![image-20200515112103496](D:\src\Typora记录\计算机硬件系统设计\image-20200515112103496.png)



10:

1,1011

1,1010

1011*1010

10:

1011+0 -> 0->01011*1+0_>001011

不难理解，当乘数为偶数时，需做n/2 次移位，最多做n/2 +1 次加法。当乘数为奇数时，乘
数高位前可只增加一个“。”，此时需做n/2 + 1 次移位（最后一步移一位〉，最多需做n/2 + I 次
加法。

### 存在的问题

#### 运算速度问题

虽然两位乘法可提高乘法速度，但它仍基于重复相加和移位的思想，而且随着乘数位数的增
加，重复次数增多，仍然影响乘法速度的进一步提高。采用并行阵列乘法器可大大提高乘法速
度。有关阵列乘法器的内容可参见附录6Bo

#### **码字转换**

原码乘法实现比较容易，但由于机器都采用补码作加减运算，倘若做乘法前再将补码转换成
原码，相乘之后又要将负积的原码变为补码形式，这样增添了许多操作步骤，反而使运算复杂。
为此，有不少机器直接用补码相乘，机器里配置实现补码乘法的乘法器，避免了码制的转换，提高
了机器效率。



## 4. 补码乘法

![image-20200515113902670](D:\src\Typora记录\计算机硬件系统设计\image-20200515113902670.png)

![image-20200515161036387](D:\src\Typora记录\计算机硬件系统设计\image-20200515161036387.png)

![image-20200515161134362](D:\src\Typora记录\计算机硬件系统设计\image-20200515161134362.png)

![image-20200515161419256](D:\src\Typora记录\计算机硬件系统设计\image-20200515161419256.png)

比较式（ 6. 13 ）与式（ 6. 11.）可见，乘数为负的补码乘法与乘数为正时类似，只需最后加上一
项校正项［ -x ］＊ 即可。

由于比较法的补码乘法运算规则不雯乘数符号的约束，因此，控制线路比较简明，在计算机
中普遍采用。
(2 ）补码比较法（ Bo。th 算法〉所需的硬件配置

![image-20200515161712993](D:\src\Typora记录\计算机硬件系统设计\image-20200515161712993.png)

流程





# 除法

![image-20200515163907990](D:\src\Typora记录\计算机硬件系统设计\image-20200515163907990.png)





### 原码除法

原码除法和原码乘法一样，符号位是单独处理的，下面以小数为例。

![image-20200515164127934](D:\src\Typora记录\计算机硬件系统设计\image-20200515164127934.png)

小数定点除法对被除数和除数有一定的约束，即必须满足下列条件：
0＜ I 被除数I <I 除数|



。商的位数一般与操作数的位数相同。

原码除法中由于对余’数的处理不同，又可分为恢复余数法和不恢复余数法（加减交替法〉两种。

#### (1 ）恢复余数法